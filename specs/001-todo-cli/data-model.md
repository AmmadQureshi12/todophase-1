# Data Model

**Feature**: In-Memory Console-Based Todo Application
**Branch**: 001-todo-cli
**Date**: 2026-02-03

## Overview

This document defines the data entities, validation rules, and state transitions for the Todo application. The design prioritizes simplicity, type safety, and clear business rules.

## Entity: Todo

### Description

Represents a single todo item with a unique identifier, description text, and completion status.

### Fields

| Field | Type | Required | Constraints | Default | Description |
|-------|------|----------|-------------|---------|-------------|
| id | int | Yes | Positive integer, unique | Auto-generated | Unique identifier for the todo |
| description | str | Yes | 1-500 characters, non-empty after strip | None | The todo task description |
| completed | bool | Yes | True or False | False | Whether the todo is completed |

### Field Details

**id (int)**:
- Auto-generated by storage layer
- Starts at 1 and increments for each new todo
- Immutable after creation
- Used for all operations (update, delete, mark complete)

**description (str)**:
- User-provided text describing the task
- Minimum length: 1 character (after stripping whitespace)
- Maximum length: 500 characters
- Leading/trailing whitespace is stripped before storage
- Can contain any UTF-8 characters including unicode
- Mutable via update operation

**completed (bool)**:
- Indicates whether the todo is done
- Defaults to False when todo is created
- Can only transition from False → True (one-way)
- Immutable once set to True (no "uncomplete" operation in Phase I)

### Python Implementation

```python
from dataclasses import dataclass

@dataclass
class Todo:
    """Represents a single todo item."""
    id: int
    description: str
    completed: bool = False

    def __post_init__(self):
        """Validate todo fields after initialization."""
        if not isinstance(self.id, int) or self.id < 1:
            raise ValueError("Todo ID must be a positive integer")

        if not isinstance(self.description, str):
            raise ValueError("Description must be a string")

        description_stripped = self.description.strip()
        if not description_stripped:
            raise ValueError("Description cannot be empty")

        if len(self.description) > 500:
            raise ValueError("Description cannot exceed 500 characters")

        if not isinstance(self.completed, bool):
            raise ValueError("Completed must be a boolean")

    def mark_complete(self) -> None:
        """Mark this todo as completed."""
        self.completed = True

    def update_description(self, new_description: str) -> None:
        """Update the todo description with validation."""
        if not isinstance(new_description, str):
            raise ValueError("Description must be a string")

        description_stripped = new_description.strip()
        if not description_stripped:
            raise ValueError("Description cannot be empty")

        if len(new_description) > 500:
            raise ValueError("Description cannot exceed 500 characters")

        self.description = new_description
```

## Entity: TodoStorage

### Description

Manages the in-memory collection of todos with CRUD operations.

### Fields

| Field | Type | Description |
|-------|------|-------------|
| _todos | Dict[int, Todo] | Internal dictionary mapping todo IDs to Todo objects |
| _next_id | int | Counter for generating unique IDs |

### Methods

**add(description: str) -> Todo**:
- Creates a new todo with the given description
- Generates unique ID using _next_id counter
- Sets completed to False by default
- Returns the created Todo object
- Raises ValueError if description is invalid

**get(todo_id: int) -> Optional[Todo]**:
- Retrieves a todo by its ID
- Returns the Todo object if found
- Returns None if ID doesn't exist
- Raises ValueError if todo_id is not a positive integer

**get_all() -> List[Todo]**:
- Returns all todos as a list
- Returns empty list if no todos exist
- Todos are returned in insertion order (Python 3.7+ dict ordering)

**update(todo_id: int, new_description: str) -> bool**:
- Updates the description of an existing todo
- Returns True if successful
- Returns False if todo_id doesn't exist
- Raises ValueError if new_description is invalid

**delete(todo_id: int) -> bool**:
- Removes a todo from storage
- Returns True if successful
- Returns False if todo_id doesn't exist

**mark_complete(todo_id: int) -> bool**:
- Marks a todo as completed
- Returns True if successful
- Returns False if todo_id doesn't exist
- Idempotent: marking an already-completed todo returns True

**exists(todo_id: int) -> bool**:
- Checks if a todo with the given ID exists
- Returns True if exists, False otherwise

**count() -> int**:
- Returns the total number of todos in storage

### Python Implementation

```python
from typing import Dict, List, Optional

class TodoStorage:
    """In-memory storage for todo items."""

    def __init__(self):
        """Initialize empty storage."""
        self._todos: Dict[int, Todo] = {}
        self._next_id: int = 1

    def add(self, description: str) -> Todo:
        """Add a new todo and return it."""
        todo = Todo(id=self._next_id, description=description, completed=False)
        self._todos[self._next_id] = todo
        self._next_id += 1
        return todo

    def get(self, todo_id: int) -> Optional[Todo]:
        """Get a todo by ID, or None if not found."""
        if not isinstance(todo_id, int) or todo_id < 1:
            raise ValueError("Todo ID must be a positive integer")
        return self._todos.get(todo_id)

    def get_all(self) -> List[Todo]:
        """Get all todos as a list."""
        return list(self._todos.values())

    def update(self, todo_id: int, new_description: str) -> bool:
        """Update a todo's description. Returns True if successful."""
        todo = self.get(todo_id)
        if todo is None:
            return False
        todo.update_description(new_description)
        return True

    def delete(self, todo_id: int) -> bool:
        """Delete a todo. Returns True if successful."""
        if todo_id in self._todos:
            del self._todos[todo_id]
            return True
        return False

    def mark_complete(self, todo_id: int) -> bool:
        """Mark a todo as complete. Returns True if successful."""
        todo = self.get(todo_id)
        if todo is None:
            return False
        todo.mark_complete()
        return True

    def exists(self, todo_id: int) -> bool:
        """Check if a todo exists."""
        return todo_id in self._todos

    def count(self) -> int:
        """Return the total number of todos."""
        return len(self._todos)
```

## Validation Rules

### Description Validation

**Rule**: Description must be 1-500 characters after stripping whitespace

**Valid Examples**:
- "Buy groceries"
- "Call mom tomorrow"
- "   Finish project report   " (stripped to "Finish project report")
- "Task with unicode: 你好世界"

**Invalid Examples**:
- "" (empty string)
- "   " (whitespace only)
- "a" * 501 (exceeds 500 characters)

**Error Messages**:
- Empty: "Description cannot be empty"
- Too long: "Description cannot exceed 500 characters"

### ID Validation

**Rule**: ID must be a positive integer

**Valid Examples**:
- 1, 2, 3, 100, 999

**Invalid Examples**:
- 0, -1, -100 (not positive)
- "1", "abc" (not integer)
- 1.5, 2.0 (not integer)

**Error Messages**:
- "Todo ID must be a positive integer"
- "Todo with ID {id} not found"

## State Transitions

### Todo Lifecycle

```
[Created] → [Active] → [Completed]
    ↓          ↓
 [Deleted]  [Deleted]
```

**States**:
1. **Created**: Todo is instantiated with completed=False
2. **Active**: Todo exists in storage and is not completed
3. **Completed**: Todo exists in storage with completed=True
4. **Deleted**: Todo is removed from storage (terminal state)

**Transitions**:
- Created → Active: Automatic upon successful add()
- Active → Completed: Via mark_complete()
- Active → Deleted: Via delete()
- Completed → Deleted: Via delete()

**Forbidden Transitions**:
- Completed → Active: No "uncomplete" operation in Phase I
- Deleted → Any: Deleted todos cannot be restored

### Completion State Rules

**One-Way Transition**:
- Once a todo is marked complete, it cannot be unmarked
- This is a Phase I constraint; future phases may add "uncomplete"

**Idempotency**:
- Calling mark_complete() on an already-completed todo succeeds (returns True)
- No error is raised; operation is idempotent

**Update Behavior**:
- Completed todos can still have their description updated
- Completed status is independent of description

## Data Integrity Constraints

### Uniqueness

**ID Uniqueness**:
- Each todo must have a unique ID
- IDs are never reused within a session
- Storage layer enforces this via auto-increment counter

### Referential Integrity

**No Orphaned References**:
- All operations reference todos by ID
- Operations on non-existent IDs return False or None (no exceptions)
- Storage layer is the single source of truth

### Consistency

**Atomic Operations**:
- All storage operations are atomic (single-threaded, in-memory)
- No partial updates possible
- No concurrent access issues (single-user application)

## Performance Characteristics

### Time Complexity

| Operation | Complexity | Rationale |
|-----------|------------|-----------|
| add() | O(1) | Dictionary insertion |
| get() | O(1) | Dictionary lookup |
| get_all() | O(n) | Iterate all todos |
| update() | O(1) | Dictionary lookup + field update |
| delete() | O(1) | Dictionary deletion |
| mark_complete() | O(1) | Dictionary lookup + field update |
| exists() | O(1) | Dictionary membership test |
| count() | O(1) | Dictionary length |

### Space Complexity

**Per Todo**: ~100-600 bytes
- int (id): ~28 bytes
- str (description): ~50-550 bytes (1-500 chars + overhead)
- bool (completed): ~28 bytes

**Total Storage**: O(n) where n is number of todos
- Expected: 1-100 todos = ~10-60 KB
- Maximum reasonable: 1000 todos = ~600 KB

## Edge Cases

### Empty Storage

**Scenario**: No todos exist
**Behavior**:
- get_all() returns empty list []
- count() returns 0
- get(any_id) returns None
- update/delete/mark_complete return False

### Maximum Description Length

**Scenario**: User enters exactly 500 characters
**Behavior**: Accepted (boundary is inclusive)

**Scenario**: User enters 501 characters
**Behavior**: Rejected with error message

### Whitespace Handling

**Scenario**: Description is "   task   "
**Behavior**: Stored as "   task   " (whitespace preserved internally)
**Note**: Validation checks stripped length, but original is stored

### ID Overflow

**Scenario**: _next_id reaches very large number
**Behavior**: Python integers have arbitrary precision; no overflow possible
**Practical Limit**: Would require billions of todos; not a concern for Phase I

### Rapid Operations

**Scenario**: User performs many operations quickly
**Behavior**: All operations are synchronous and atomic; no race conditions

## Testing Strategy

### Unit Tests Required

**Todo Entity**:
- Test valid creation with all fields
- Test validation errors (empty description, too long, invalid types)
- Test mark_complete() transition
- Test update_description() with valid/invalid inputs

**TodoStorage**:
- Test add() creates todo with correct ID
- Test get() retrieves correct todo
- Test get_all() returns all todos
- Test update() modifies description
- Test delete() removes todo
- Test mark_complete() changes status
- Test operations on non-existent IDs
- Test ID auto-increment behavior

### Integration Tests Required

**Full Workflows**:
- Add multiple todos, verify IDs increment
- Add, update, mark complete, verify state
- Add, delete, verify removal
- Add multiple, get_all, verify order

### Edge Case Tests Required

- Empty description (after strip)
- 500-character description (boundary)
- 501-character description (over limit)
- Operations on empty storage
- Operations on non-existent IDs
- Unicode in descriptions

## Future Considerations (Out of Scope for Phase I)

- **Uncomplete operation**: Allow completed → active transition
- **Todo priority**: Add priority field (low/medium/high)
- **Due dates**: Add optional due_date field
- **Categories/tags**: Add categorization
- **Timestamps**: Add created_at, updated_at fields
- **Soft delete**: Mark as deleted instead of removing
- **Undo/redo**: Track operation history

These features are explicitly out of scope for Phase I per the specification.
